module.exports = grammar({
  name: 'kql',

  extras: $ => [
    token(/\s/),
    $.line_comment,
    $.block_comment
  ],

  conflicts: $ => [
    [$.distinct_clause],
    [$.parse_pattern]
  ],

  rules: {
    source_file: ($) => repeat($._statement),
    _statement: ($) => choice($.let_statement, $.query_statement),
    let_statement: ($) => seq("let", $.identifier, "=", $.expression, ";"),
    query_statement: ($) => seq($.table_name, repeat($.pipe_expression)),
    pipe_expression: ($) => seq("|", $.operator),
    operator: ($) => choice($.where_clause, $.project_clause, $.extend_clause, $.summarize_clause, $.join_clause, $.union_clause, $.parse_clause, $.mv_expand_clause, $.take_clause, $.limit_clause, $.sort_clause, $.order_clause, $.distinct_clause, $.count_clause, $.top_clause, $.search_clause),
    table_name: ($) => $.identifier,
    where_clause: ($) => prec.left(seq("where", $.expression)),
    project_clause: ($) => seq("project", $.column_list),
    extend_clause: ($) => seq("extend", $.column_list),
    summarize_clause: ($) => seq("summarize", $.aggregation_list, optional(seq("by", $.expression_list))),
    aggregation_list: ($) => seq($.aggregation_expression, repeat(seq(",", $.aggregation_expression))),
    aggregation_expression: ($) => choice(seq($.identifier, "=", $.expression), $.expression),
    expression_list: ($) => seq($.expression, repeat(seq(",", $.expression))),
    join_clause: ($) => seq("join", optional(seq("kind", "=", $.join_kind)), choice(seq("(", $.table_name, ")"), $.table_name), "on", $.join_conditions),
    join_kind: ($) => choice("inner", "leftouter", "rightouter", "leftanti", "rightanti", "leftsemi", "rightsemi", "fullouter"),
    join_conditions: ($) => seq($.join_condition, repeat(seq(",", $.join_condition))),
    join_condition: ($) => choice(seq(optional("$left."), $.identifier, "==", optional("$right."), $.identifier), $.identifier),
    union_clause: ($) => seq("union", optional(seq("kind", "=", $.union_kind)), optional(seq("isfuzzy", "=", choice("true", "false"))), $.table_list),
    union_kind: ($) => choice("inner", "outer"),
    table_list: ($) => seq($.table_name, repeat(seq(",", $.table_name))),
    parse_clause: ($) => seq("parse", optional(seq("kind", "=", $.parse_kind)), optional(seq("flags", "=", $.string_literal)), $.expression, "with", $.parse_pattern),
    parse_kind: ($) => choice("simple", "regex", "relaxed"),
    parse_pattern: ($) => seq(optional("*"), $.string_literal, repeat(seq($.identifier, optional(seq(":", $.identifier)), optional($.string_literal))), optional("*")),
    mv_expand_clause: ($) => seq(choice("mv-expand", "mvexpand"), $.expression, optional(seq("to", "typeof", "(", $.identifier, ")")), optional(seq("limit", $.number_literal))),
    take_clause: ($) => seq("take", $.number_literal),
    limit_clause: ($) => seq("limit", $.number_literal),
    top_clause: ($) => seq("top", $.number_literal, optional(seq("by", $.identifier, optional(choice("asc", "desc"))))),
    search_clause: ($) => seq("search", optional(seq("in", "(", $.column_list, ")")), $.string_literal),
    sort_clause: ($) => seq("sort", optional("by"), $.sort_expression_list),
    order_clause: ($) => seq("order", "by", $.sort_expression_list),
    sort_expression_list: ($) => seq($.sort_expression, repeat(seq(",", $.sort_expression))),
    sort_expression: ($) => seq($.identifier, optional(choice("asc", "desc"))),
    distinct_clause: ($) => choice(prec.dynamic(1, seq("distinct", $.column_list)), prec.dynamic(0, "distinct")),
    count_clause: ($) => "count",
    column_list: ($) => seq($.column_expression, repeat(seq(",", $.column_expression))),
    column_expression: ($) => choice($.column_assignment, $.expression),
    column_assignment: ($) => seq($.identifier, "=", $.expression),
    expression: ($) => choice($.binary_expression, $.comparison_expression, $.arithmetic_expression, $.string_expression, $.in_expression, $.between_expression, $.parenthesized_expression, $.conditional_expression, $.type_cast_expression, $.function_call, $.literal, $.qualified_identifier, $.identifier),
    conditional_expression: ($) => choice(seq("iff", "(", $.expression, ",", $.expression, ",", $.expression, ")"), seq("case", "(", $.expression, repeat(seq(",", $.expression)), ")")),
    binary_expression: ($) => prec.left(1, seq($.expression, choice("and", "or"), $.expression)),
    comparison_expression: ($) => prec.left(2, seq($.expression, choice("==", "!=", ">", "<", ">=", "<="), $.expression)),
    arithmetic_expression: ($) => choice(prec.left(4, seq($.expression, choice("*", "/", "%"), $.expression)), prec.left(3, seq($.expression, choice("+", "-"), $.expression))),
    parenthesized_expression: ($) => seq("(", $.expression, ")"),
    string_expression: ($) => prec.left(2, seq($.identifier, choice("contains", "startswith", "endswith", "matches", "has"), $.string_literal)),
    in_expression: ($) => prec.left(2, seq($.identifier, "in", "(", $.literal_list, ")")),
    between_expression: ($) => prec.left(2, seq($.identifier, "between", "(", $.literal, "..", $.literal, ")")),
    literal_list: ($) => seq($.literal, repeat(seq(",", $.literal))),
    literal: ($) => choice($.string_literal, $.number_literal, $.boolean_literal, $.null_literal, $.timespan_literal, $.array_literal, $.dynamic_literal),
    string_literal: ($) => choice(seq("\"", /[^"]*/, "\""), seq("'", /[^']*/, "'")),
    number_literal: ($) => /\d+(\.\d+)?/,
    boolean_literal: ($) => choice("true", "false"),
    null_literal: ($) => "null",
    timespan_literal: ($) => /\d+(\.\d+)?(d|h|m|s|ms|microsecond|tick)/,
    array_literal: ($) => seq("[", optional($.array_elements), "]"),
    array_elements: ($) => seq($.expression, repeat(seq(",", $.expression))),
    dynamic_literal: ($) => seq("dynamic", "(", choice($.string_literal, $.array_literal, $.number_literal), ")"),
    identifier: ($) => /[a-zA-Z_][a-zA-Z0-9_]*/,
    qualified_identifier: ($) => seq($.identifier, ".", $.identifier),
    type_cast_expression: ($) => choice(seq($.expression, "::", $.identifier), seq("to", $.identifier, "(", $.expression, ")")),
    function_call: ($) => seq($.identifier, "(", optional($.argument_list), ")"),
    argument_list: ($) => seq($.argument, repeat(seq(",", $.argument))),
    argument: ($) => choice($.named_argument, $.expression),
    named_argument: ($) => seq($.identifier, "=", $.expression),
    line_comment: ($) => token(seq("//", /[^\r\n]*/)),
    block_comment: ($) => token(seq("/*", /[^*]*\*+(?:[^\/*][^*]*\*+)*/, "/")),
  }
});
