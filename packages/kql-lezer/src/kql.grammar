@top Query { statement }

statement { pipelineExpression | letStatement statement? }

letStatement { kw<"let"> Identifier Equals expression Semicolon }

pipelineExpression { tableExpression (Pipe operator)* }

tableExpression { Identifier }

operator {
  whereClause |
  projectClause |
  extendClause |
  sortClause |
  limitClause |
  takeClause |
  topClause |
  distinctClause |
  summarizeClause |
  joinClause |
  Identifier |
  Number |
  String
}

joinClause { kw<"join"> joinKind? tableExpression kw<"on"> expression }

projectClause { kw<"project"> columnList }

extendClause { kw<"extend"> columnList }

sortClause { kw<"sort"> kw<"by">? sortColumnList }

sortColumnList { sortColumn (Comma sortColumn)* }

sortColumn { Identifier (kw<"asc"> | kw<"desc">)? }

limitClause { kw<"limit"> Number }

takeClause { kw<"take"> Number }

topClause { kw<"top"> Number kw<"by">? Identifier (kw<"asc"> | kw<"desc">)? }

distinctClause { kw<"distinct"> columnNameList }

columnNameList { Identifier (Comma Identifier)* }

summarizeClause { kw<"summarize"> aggregationList (kw<"by"> columnNameList)? }

aggregationList { aggregation (Comma aggregation)* }

aggregation { Identifier Equals aggregateFunction | aggregateFunction }

aggregateFunction { functionName OpenParen argumentList? CloseParen }

functionName { Identifier }

argumentList { expression (Comma expression)* }

joinKind {
  kw<"inner"> | kw<"leftouter"> | kw<"rightouter"> | kw<"fullouter"> |
  kw<"leftanti"> | kw<"rightanti"> | kw<"leftsemi"> | kw<"rightsemi">
}

columnList { columnSpec (Comma columnSpec)* }

columnSpec {
  Identifier (Equals expression)?
}

whereClause { kw<"where"> expression }

expression {
  orExpression
}

orExpression {
  andExpression (kw<"or"> andExpression)*
}

andExpression {
  notExpression (kw<"and"> notExpression)*
}

notExpression {
  kw<"not"> notExpression |
  comparisonExpression
}

comparisonExpression {
  sumExpression (comparisonOperator sumExpression)*
}

sumExpression {
  termExpression ((Plus | Minus) termExpression)*
}

termExpression {
  primaryExpression ((Star | Slash | Percent) primaryExpression)*
}

primaryExpression {
  functionCall |
  OpenParen expression CloseParen |
  literal |
  columnReference
}

columnReference {
  Identifier (OpenBracket expression CloseBracket)*
}

functionCall { functionName OpenParen argumentList? CloseParen }

comparisonOperator {
  ComparisonOp |
  kw<"contains"> | kw<"!contains"> |
  kw<"startswith"> | kw<"endswith"> |
  kw<"has"> | kw<"!has"> |
  kw<"in"> | kw<"!in">
}

literal {
  Number | String
}

kw<term> { @specialize[@name={term}]<Identifier, term> }

@tokens {
  Pipe { "|" }
  OpenParen { "(" }
  CloseParen { ")" }
  OpenBracket { "[" }
  CloseBracket { "]" }
  Comma { "," }
  Semicolon { ";" }
  Equals { "=" }

  // Math operators
  Plus { "+" }
  Minus { "-" }
  Star { "*" }
  Slash { "/" }
  Percent { "%" }

  Identifier { $[a-zA-Z_] $[a-zA-Z0-9_]* }
  Number { @digit+ ("." @digit+)? }
  String { '"' (!["\\\n] | "\\" _)* '"' | "'" (!['\\\n] | "\\" _)* "'" }
  ComparisonOp { "==" | "!=" | ">=" | "<=" | ">" | "<" }
  LineComment { "//" ![\n]* }
  whitespace { $[ \t\n\r]+ }

  @precedence { LineComment, Slash }
}

@skip { whitespace | LineComment }
