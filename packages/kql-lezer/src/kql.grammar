@top Query { statement }

statement { pipelineExpression | letStatement statement? }

letStatement { kw<"let"> identifier Equals expression Semicolon }

pipelineExpression { tableExpression (Pipe operator)* }

tableExpression { identifier }

identifier { Identifier | bracketedIdentifier }

bracketedIdentifier { OpenBracket String CloseBracket }

operator {
  whereClause |
  projectClause |
  projectAwayClause |
  projectKeepClause |
  projectRenameClause |
  projectReorderClause |
  extendClause |
  sortClause |
  limitClause | 
  takeClause |
  topClause |
  distinctClause |
  summarizeClause |
  joinClause |
  identifier |
  Number |
  String
}

joinClause { kw<"join"> joinKind? tableExpression kw<"on"> expression }

projectClause { kw<"project"> columnList }

projectAwayClause  { (kw<"project-away"> | kw<"projectaway">) columnList }
projectKeepClause  { (kw<"project-keep"> | kw<"projectkeep">) columnList }
projectRenameClause { (kw<"project-rename"> | kw<"projectrename">) columnList } 
projectReorderClause { (kw<"project-reorder"> | kw<"projectreorder">) columnList }

extendClause { kw<"extend"> columnList }

sortClause { kw<"sort"> kw<"by">? sortColumnList }

sortColumnList { sortColumn (Comma sortColumn)* }

sortColumn { identifier (kw<"asc"> | kw<"desc">)? }

limitClause { kw<"limit"> Number }

takeClause { kw<"take"> Number }

topClause { kw<"top"> Number kw<"by">? identifier (kw<"asc"> | kw<"desc">)? }

distinctClause { kw<"distinct"> columnNameList }

columnNameList { identifier (Comma identifier)* }

summarizeClause { kw<"summarize"> aggregationList (kw<"by"> columnNameList)? }

aggregationList { aggregation (Comma aggregation)* }

aggregation { identifier Equals aggregateFunction | aggregateFunction }

aggregateFunction { functionName OpenParen argumentList? CloseParen }

functionName { identifier }

argumentList { expression (Comma expression)* }

joinKind {
  kw<"inner"> | kw<"leftouter"> | kw<"rightouter"> | kw<"fullouter"> |
  kw<"leftanti"> | kw<"rightanti"> | kw<"leftsemi"> | kw<"rightsemi">
}

columnList { columnSpec (Comma columnSpec)* }

columnSpec {
  identifier (Equals expression)?
}

whereClause { kw<"where"> expression }

expression {
  orExpression
}

orExpression {
  andExpression (kw<"or"> andExpression)*
}

andExpression {
  notExpression (kw<"and"> notExpression)*
}

notExpression {
  kw<"not"> notExpression |
  comparisonExpression
}

comparisonExpression {
  sumExpression (comparisonOperator sumExpression)*
}

sumExpression {
  termExpression ((Plus | Minus) termExpression)*
}

termExpression {
  primaryExpression ((Star | Slash | Percent) primaryExpression)*
}

primaryExpression {
  functionCall |
  OpenParen expression CloseParen |
  literal |
  columnReference
}

columnReference {
  identifier (OpenBracket expression CloseBracket)*
}

functionCall { functionName OpenParen argumentList? CloseParen }

comparisonOperator {
  ComparisonOp |
  kw<"contains"> | kwRenamed<"!contains", "NotContains"> |
  kw<"startswith"> | kw<"endswith"> |
  kw<"has"> | kwRenamed<"!has", "NotHas"> |
  kw<"in"> | kwRenamed<"!in", "NotIn">
}

literal {
  Number | String
}

kwRenamed<term, name> { @specialize[@name={name}]<Identifier, term> }
kw<term> { @specialize[@name={term}]<Identifier, term> }

@tokens {
  Pipe { "|" }
  OpenParen { "(" }
  CloseParen { ")" }
  OpenBracket { "[" }
  CloseBracket { "]" }
  Comma { "," }
  Semicolon { ";" }
  Equals { "=" }

  // Math operators
  Plus { "+" }
  Minus { "-" }
  Star { "*" }
  Slash { "/" }
  Percent { "%" }

  Identifier { $[a-zA-Z_] $[a-zA-Z0-9_]* }
  Number { @digit+ ("." @digit+)? }
  String { '"' (!["\\\n] | "\\\\" _)* '"' | "'" (!['\\\n] | "\\\\" _)* "'" }
  ComparisonOp { "==" | "!=" | ">=" | "<=" | ">" | "<" }
  LineComment { "//" ![
]* }
  whitespace { $[ \t\n\r]+ }

  @precedence { LineComment, Slash }
}

@skip { whitespace | LineComment }
